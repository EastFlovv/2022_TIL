## Intersction Observer API (교차 관찰자 API)

```js
const io = new IntersectionObserver(callback[, options]);
```
- function callback(enrty, observer)
  - entry ({object} array): 더 드러나거나 가려져서 지정한 역치를 넘어가게 된 객체의 배열
  - observer: 콜백을 호출한 IntersectionObserver

- options
  - root: 대상 요소의 조상 Element 또는 Document, 지정하지 않거나 null지정시 viewport사용
  - rootMargin: 교차 계산의 root의 바운딩 박스에 적용할 오프셋 즉, 교차 계산 시 루트 영역의 크기를 키우거나 줄이고자 할 때 사용
  - threshold: 0.0이상 1.0이하의 숫자 단일 값 혹은 숫자 배열. 대상의 보이는 영역과 전체 바운딩 박스의 비율에 대한 역치

- 메서드
  - observe(): 대상 요소를 주시
  - takeRecords(): 모든 주시 대상에 대한 IntersectionObserverEntry 배열을 반환
  - unobserve(): 특정 요소에 대한 주시 해제
  - disconnect(): 모든 대상의 주시 해제

## 리팩터링
소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

- 두개의 모자  
기능 추가와 리팩터링을 명확하게 구분할것  
리팩터링 모자를 썼을 때는, 테스트 마저 수정하지 않는다.

- 리팩터링을 하는 이유
  1. 소프트웨어 설계가 좋아진다.
  2. 소프트웨어를 이해하기 쉬워진다.
  3. 버그를 쉽게 찾을 수 있다.  
  => 프로그래밍 속도의 증가

- 설계 지구력 가설  
내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.

- 리팩터링을 하는 시점
  1. 같은 일을 세번 할때  
  2. 준비를 위한 리팩터링   
  기능을 추가하기 직전에, '리팩터링을 하면 더 쉽게 추가 할 수 있지 않을까' 고민
  3. 이해를 위한 리팩터링  
  코드를 파악해야 할 일이 있을 때, 이해한 내용을 더 잘 반영할 수 있도록 리팩터링
  4. 쓰레기 줍기 리팩터링  
  코드를 파악하다가 '비효율적으로 처리하는 모습을 발견'하면 리팩터링

- YAGNI(You Aren't Going to Need It)
  1. 코딩을 시작하기 전에 아키텍쳐를 확정  
  요구사항 사전 파악은 현실적으로 불가능하다.
  2. 유연성 매커니즘 심어두기  
  되려 대응능력의 저해
  3. YAGNI

  => 선제적 아키텍쳐에 소홀하라는것이 아닌 이미 알고있는 부분은 최대한 미리 준비하는게 좋고 모르는것을 미리 대비하기 보다, 이해하고 나서 반영하는게 효율적이다.  

- 리팩터링과 성능  
리팩터링을 통해 성능이 낮아지더라도 분할된 성능을 튜닝하기 쉬워지므로 오히려 성능을 높일 수 있다.


## 코드의 악취
- 악취: 냄새의 메타포, 리팩터링이 필요한 코드  

기이한 이름, 중복 코드, 긴 함수, 긴 매개변수 목록, 전역 데이터, 가변 데이터, 뒤엉킨 변경(한 코드에 여럿이 섞여 들어감), 산탄총 수술(여러 코드에 흩뿌려짐), 기능편애, 데이터 뭉치, 기본형 집착, 반복문, 반복되는 switch문, 성의없는 요소, 추측성 일반화, 임시 필드, 메시지 체인, 중개자, 내부자 거래, 거대한 클래스, 서로 다른 인터페이스의 대안 클래스들, 데이터 클래스, 상속 포기, 주석

## 테스트
리팩터링동안 겉보기 동작이 제대로 유지되는지 테스트를 통해 검증
- 유닛 테스트  

## css
- form
```css
.className {
  /* Attributes */
}
```

- 선택자
  - 전체 선택자: *
  - 태그 선택자: E
  - 클래스 선택자: .E
  - 아이디 선택자: #E

- 복합 선택자
  - 일치 선택자: EF
  - 자식 선택자: E > F
  - 후손 선택자: E F
  - 인접 형제 선택자: E + F

- 상속: 주로 글자를 다루는 속성이 상속된다.

- 가상 클래스 선택자
  - hover: 마우스 오버시 처리
  - active: 마우스로 클릭하는동안 처리
  - focus: 대화형 컨텐츠가 포커스된 동안의 처리
  - first-child: 형제 요소 중 첫번째를 선택
  - last-child: 형제 요소 중 마지막요소를 선택
  - nth-child: 형제요소중 n번째 요소를 선택(n키워드를 통해 0부터 해석) (n+3, 2n, 3n...)

## 회고
확실한 목표를 위해 동시에 여러가지 일을 하지말고 집중적으로 해야겠다.
매주 확실히 해야할것으로 시크릿코드 강의듣기, JS복습, 코딩문제풀이를 중심으로 그리고 TIL 자주 올리기